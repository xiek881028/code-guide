{"./":{"url":"./","title":"介绍","keywords":"","body":"前端代码规范 介绍 目前金服前端维护的项目日益增多，前端队伍日益壮大，项目工程中前端代码量越来越多。不同的开发人员带来了不同的代码风格和编码习惯，使项目代码阅读难度越来越大，提高了项目维护成本与新人员加入项目的入门门槛。基于这种情况，制定该代码规范，以求达到以下几点目标： 降低新成员融入团队的成本 提高开发效率、团队协作效率、降低沟通成本 实现统一的代码风格，方便review，提高项目的可维护性 为未来页面外包 具体规范 项目工程规范 JS规范 JS规范 - react JS规范 - Node CSS规范 HTML规范 图片规范 推荐工具 prettier - 🔥 自动化代码格式工具，支持大部分前端常用IDE 参考文献 airbnb 百度前端代码规范 O2前端规范 腾讯互动娱乐外包页面代码规范 阿里巴巴Java开发手册 Copyright © xiek 2021 all right reserved，powered by Gitbook文档更新时间： 2021-03-11 15:23:00 "},"page/project.html":{"url":"page/project.html","title":"项目工程规范","keywords":"","body":"项目工程规范 该文档主要的设计目标是统一项目工程规范，方便查找与使用。 通用项目工程 通用项目组织规范 [强制] 在一个前端项目或前端工具包中，必须包含以下文件 README.md 包含项目的关键信息以及其他关键事项。一般包含以下信息： 简要描述项目背景，项目主要特征 运行环境，技术栈，安装和构建命令 简单示例代码 文档或文档入口 联系方式、讨论群 许可、贡献 开发指南 CHANGELOG.md 放置每个版本的变动内容，让使用者方便了解项目更新情况。随着版本同步维护。 package.json 包描述文件，包含基础的配置信息。包含如下： name[必须] 包名 version[必须] 版本号。必须符合semver格式约定 maintainers[必须] 维护者列表。该字段必须为一个数组，数组中每一项必须包含name和email字段 contributions[必须] 贡献者列表。该字段必须为一个数组，数组中每一项必须包含name和email字段。原则上该字段不允许删除，按字母顺序排列。每个人的劳动成果都应该被尊重 description[可选]\\ 包描述 keywords[可选]\\ 关键词 author[可选]\\ 作者 licenses[可选]\\ 许可证列表 homepage[可选]\\ 网站地址 目录组织的风格 目录有两种组织模式： Rails-style*(职能)：按照文件的类型划分为不同的目录，例如components、constants、 typings、views Domain-style(功能特性、业务逻辑)：按照一个功能特性或业务创建单独的目录，这个目录就近包含多种类型的文件或目录 ${root}目录结构划分 [强制] 在${root}下，目录必须以职能模式划分，不允许将资源类型或业务逻辑划分的目录直接置于${root}下 非${root}目录结构 [强制] 在非${root}下，可以根据实际情况选择目录组织模式。但禁止在同级目录中同时出现职能模式划分与资源类型或业务逻辑模式划分 目录命名原则 [强制] 简洁。有习惯缩写的单词，建议采用容易理解的缩写，但不可为了追求简洁过度缩写造成理解困难。例如 img 图片。bad：image、images、imgs js javascript 脚本。bad：script、scripts、javascript css 样式表。bad：style、styles src 源文件目录。bad：source lib 引入的第三方依赖包目录。bad：library、dependency [强制] 不允许（讨论）使用复数形式 [强制] 命名必须使用小驼峰命名法 web 项目工程 浏览器兼容策略 渐进增强 or 优雅降级？ 渐进增强保证低版本浏览器的体验，对于支持新特性的新浏览器提供稍好的体验 优雅降级则是相反的，为现代浏览器提供最好的体验，而旧浏览器则退而求之次，保证大概的功能 浏览器兼容性 标准浏览器最新版、IE11+ Copyright © xiek 2021 all right reserved，powered by Gitbook文档更新时间： 2021-03-10 15:44:39 "},"page/js.html":{"url":"page/js.html","title":"JS规范","keywords":"","body":"js 规范 该文档主要的设计目标是统一 js 的一致性和可维护性。 代码风格 模块风格 [强制] 为了保证模块兼容性，运行在nodejs或需要同时运行在nodejs与浏览器的环境里的模块，使用CommonJS风格，只需要在浏览器端运行的模块，推荐使用ES6风格。 前端模块目前分为CommonJS，AMD，CMD，ES64种风格，nodejs是CommonJS规范的主要实践者，可以保证最好的兼容性 文件 [强制] js文件使用utf-8编码 缩进 [强制] tab 用两个空格. eslint: indent // bad function foo() { ∙∙∙∙const name; } // bad function bar() { ∙const name; } // good function baz() { ∙∙const name; } [强制] 在大括号前空一格。 eslint: space-before-blocks // bad function test() { console.log('test'); } // good function test() { console.log('test'); } // bad dog.set('attr', { age: '1 year', breed: 'Bernese Mountain Dog', }); // good dog.set('attr', { age: '1 year', breed: 'Bernese Mountain Dog', }); [待定] 在控制语句(if, while 等)的圆括号前空一格。在函数调用和定义时，参数列表和函数名之间不空格。 eslint: keyword-spacing // bad if(isJedi) { fight (); } // good if (isJedi) { fight(); } // bad function fight () { console.log ('Swooosh!'); } // good function fight() { console.log('Swooosh!'); } [强制] 用空格来隔开运算符。 eslint: space-infix-ops // bad const x=y+5; // good const x = y + 5; [强制] 文件结尾空一行. eslint: eol-last // bad import { es6 } from './AirbnbStyleGuide'; // ... export default es6; // bad import { es6 } from './AirbnbStyleGuide'; // ... export default es6;↵ ↵ // good import { es6 } from './AirbnbStyleGuide'; // ... export default es6;↵ [强制] 在一个代码块后下一条语句前空一行。 // bad if (foo) { return bar; } return baz; // good if (foo) { return bar; } return baz; // bad const obj = { foo() {}, bar() {}, }; return obj; // good const obj = { foo() {}, bar() {}, }; return obj; // bad const arr = [function foo() {}, function bar() {}]; return arr; // good const arr = [function foo() {}, function bar() {}]; return arr; [强制] 不要用空白行填充块。 eslint: padded-blocks // bad function bar() { console.log(foo); } // also bad if (baz) { console.log(qux); } else { console.log(foo); } // good function bar() { console.log(foo); } // good if (baz) { console.log(qux); } else { console.log(foo); } [强制] 不要在代码之间使用多个空白行填充。 eslint: no-multiple-empty-lines // bad class Person { constructor(fullName, email, birthday) { this.fullName = fullName; this.email = email; this.setAge(birthday); } setAge(birthday) { const today = new Date(); const age = this.getAge(today, birthday); this.age = age; } getAge(today, birthday) { // .. } } // good class Person { constructor(fullName, email, birthday) { this.fullName = fullName; this.email = email; this.setAge(birthday); } setAge(birthday) { const today = new Date(); const age = getAge(today, birthday); this.age = age; } getAge(today, birthday) { // .. } } [强制] 圆括号里不要加空格。 eslint: space-in-parens // bad function bar( foo ) { return foo; } // good function bar(foo) { return foo; } // bad if ( foo ) { console.log(foo); } // good if (foo) { console.log(foo); } [强制] 方括号里不要加空格。看示例。 eslint: array-bracket-spacing // bad const foo = [ 1, 2, 3 ]; console.log(foo[ 0 ]); // good， 逗号分隔符还是要空格的 const foo = [1, 2, 3]; console.log(foo[0]); [强制] 花括号里加空格。 eslint: object-curly-spacing // bad const foo = {clark: 'kent'}; // good const foo = { clark: 'kent' }; [建议] 避免一行代码超过 100 个字符（包含空格）。 [强制] 注意： 对于上面——strings--line-length，长字符串不受此规则限制，不应分解。 eslint: max-len Why? 这样确保可读性和可维护性 // bad const foo = jsonData && jsonData.foo && jsonData.foo.bar && jsonData.foo.bar.baz && jsonData.foo.bar.baz.quux && jsonData.foo.bar.baz.quux.xyzzy; // bad $.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' } }).done(() => console.log('Congratulations!')).fail(() => console.log('You have failed this city.')); // good const foo = jsonData && jsonData.foo && jsonData.foo.bar && jsonData.foo.bar.baz && jsonData.foo.bar.baz.quux && jsonData.foo.bar.baz.quux.xyzzy; // good $.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' }, }) .done(() => console.log('Congratulations!')) .fail(() => console.log('You have failed this city.')); [强制] 作为语句的花括号内也要加空格 —— { 后和 } 前都需要空格。 eslint: block-spacing // bad function foo() {return true;} if (foo) { bar = 0;} // good function foo() { return true; } if (foo) { bar = 0; } [强制] , 前不要空格， , 后需要空格。 eslint: comma-spacing // bad var foo = 1,bar = 2; var arr = [1 , 2]; // good var foo = 1, bar = 2; var arr = [1, 2]; [强制] 计算属性内要空格。参考上述花括号和中括号的规则。 eslint: computed-property-spacing // bad obj[foo ] obj[ 'foo'] var x = {[ b ]: a} obj[foo[ bar ]] // good obj[foo] obj['foo'] var x = { [b]: a } obj[foo[bar]] [强制] 调用函数时，函数名和小括号之间不要空格。 eslint: func-call-spacing // bad func (); func (); // good func(); [强制] 在对象的字面量属性中， key value 之间要有空格。 eslint: key-spacing // bad var obj = { \"foo\" : 42 }; var obj2 = { \"foo\":42 }; // good var obj = { \"foo\": 42 }; [强制] 行末不要空格。 eslint: no-trailing-spaces [强制] 避免出现多个空行。 在文件末尾只允许空一行。 eslint: no-multiple-empty-lines // bad var x = 1; ↵ ↵ ↵ var y = 2; // good var x = 1; var y = 2; 逗号 [强制] 不要前置逗号。 eslint: comma-style // bad const story = [ once , upon , aTime ]; // good const story = [ once, upon, aTime, ]; // bad const hero = { firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers' }; // good const hero = { firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers', }; [强制] 额外结尾逗号: 要 eslint: comma-dangle Why? 这导致 git diffs 更清洁。 此外，像 Babel 这样的转换器会删除转换代码中的额外的逗号，这意味着你不必担心旧版浏览器中的结尾逗号问题。 // bad - 没有结尾逗号的 git diff const hero = { firstName: 'Florence', - lastName: 'Nightingale' + lastName: 'Nightingale', + inventorOf: ['coxcomb chart', 'modern nursing'] }; // good - 有结尾逗号的 git diff const hero = { firstName: 'Florence', lastName: 'Nightingale', + inventorOf: ['coxcomb chart', 'modern nursing'], }; // bad const hero = { firstName: 'Dana', lastName: 'Scully' }; const heroes = [ 'Batman', 'Superman' ]; // good const hero = { firstName: 'Dana', lastName: 'Scully', }; const heroes = [ 'Batman', 'Superman', ]; // bad function createHero( firstName, lastName, inventorOf ) { // does nothing } // good function createHero( firstName, lastName, inventorOf, ) { // does nothing } // good (note that a comma must not appear after a \"rest\" element) function createHero( firstName, lastName, inventorOf, ...heroArgs ) { // does nothing } // bad createHero( firstName, lastName, inventorOf ); // good createHero( firstName, lastName, inventorOf, ); // good (note that a comma must not appear after a \"rest\" element) createHero( firstName, lastName, inventorOf, ...heroArgs ) 分号 [强制] Yup. eslint: semi Why? 当 JavaScript 遇到没有分号结尾的一行，它会执行自动插入分号 Automatic Semicolon Insertion这一规则来决定行末是否加分号。如果 JavaScript 在你的断行里错误的插入了分号，就会出现一些古怪的行为。当新的功能加到 JavaScript 里后， 这些规则会变得更复杂难懂。显示的结束语句，并通过配置代码检查去捕获没有带分号的地方可以帮助你防止这种错误。 // bad (function () { const name = 'Skywalker' return name })() // good (function () { const name = 'Skywalker'; return name; }()); // good, 行首加分号，避免文件被连接到一起时立即执行函数被当做变量来执行。 ;(() => { const name = 'Skywalker'; return name; }()); Read more. 命名约定 [强制] 避免用一个字母命名，让你的命名可描述。 eslint: id-length // bad function q() { // ... } // good function query() { // ... } [强制] 用小驼峰式命名你的对象、函数、实例。 eslint: camelcase // bad const OBJEcttsssss = {}; const this_is_my_object = {}; function c() {} // good const thisIsMyObject = {}; function thisIsMyFunction() {} [强制] 用大驼峰式命名类。 eslint: new-cap // bad function user(options) { this.name = options.name; } const bad = new user({ name: 'nope', }); // good class User { constructor(options) { this.name = options.name; } } const good = new User({ name: 'yup', }); [强制] 不要用前置或后置下划线。 eslint: no-underscore-dangle Why? JavaScript 没有私有属性或私有方法的概念。尽管前置下划线通常的概念上意味着“private”，事实上，这些属性是完全公有的，因此这部分也是你的 API 的内容。这一概念可能会导致开发者误以为更改这个不会导致崩溃或者不需要测试。 如果你想要什么东西变成“private”，那就不要让它在这里出现。 // bad this.__firstName__ = 'Panda'; this.firstName_ = 'Panda'; this._firstName = 'Panda'; // good this.firstName = 'Panda'; [建议] 不要保存引用this， 用箭头函数或函数绑定——Function#bind. // bad function foo() { const self = this; return function () { console.log(self); }; } // bad function foo() { const that = this; return function () { console.log(that); }; } // good function foo() { return () => { console.log(this); }; } [强制] export default 导出模块 A，则这个文件名也叫 A.*， import 时候的参数也叫 A。 大小写完全一致。 // file 1 contents class CheckBox { // ... } export default CheckBox; // file 2 contents export default function fortyTwo() { return 42; } // file 3 contents export default function insideDirectory() {} // in some other file // bad import CheckBox from './checkBox'; // PascalCase import/export, camelCase filename import FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase export import InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export // bad import CheckBox from './check_box'; // PascalCase import/export, snake_case filename import forty_two from './forty_two'; // snake_case import/filename, camelCase export import inside_directory from './inside_directory'; // snake_case import, camelCase export import index from './inside_directory/index'; // requiring the index file explicitly import insideDirectory from './insideDirectory/index'; // requiring the index file explicitly // good import CheckBox from './CheckBox'; // PascalCase export/import/filename import fortyTwo from './fortyTwo'; // camelCase export/import/filename import insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\" // ^ supports both insideDirectory.js and insideDirectory/index.js [强制] 当你 export-default 一个函数时，函数名用小驼峰，文件名需要和函数名一致。 function makeStyleGuide() { // ... } export default makeStyleGuide; [强制] 当你 export 一个结构体/类/单例/函数库/对象 时用大驼峰。 const AirbnbStyleGuide = { es6: {}, }; export default AirbnbStyleGuide; [强制] 简称和缩写应该全部大写或全部小写。 Why? 名字都是给人读的，不是为了适应电脑的算法的。 // bad import SmsContainer from './containers/SmsContainer'; // bad const HttpRequests = [ // ... ]; // good import SMSContainer from './containers/SMSContainer'; // good const HTTPRequests = [ // ... ]; // also good const httpRequests = [ // ... ]; // best import TextMessageContainer from './containers/TextMessageContainer'; // best const requests = [ // ... ]; [强制] 你可以用全大写字母设置静态变量，他需要满足三个条件。 导出变量 是 const 定义的， 保证不能被改变 这个变量是可信的，他的子属性都是不能被改变的 Why? 这是一个附加工具，帮助开发者去辨识一个变量是不是不可变的。 对于所有的 const 变量呢？ —— 这个是不必要的。大写变量不应该在同一个文件里定义并使用， 它只能用来作为导出变量。 赞同！ 那导出的对象呢？ —— 大写变量处在 export 的最高级(e.g. EXPORTED_OBJECT.key) 并且他包含的所有子属性都是不可变的。 // bad const PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file'; // bad export const THING_TO_BE_CHANGED = 'should obviously not be uppercased'; // bad export let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables'; // --- // 允许但不够语义化 export const apiKey = 'SOMEKEY'; // 在大多数情况下更好 export const API_KEY = 'SOMEKEY'; // --- // bad - 不必要的大写键，没有增加任何语义 export const MAPPING = { KEY: 'value', }; // good export const MAPPING = { key: 'value', }; 判断 [建议] 对于多层的if/else嵌套判断，应尽量减少不必要的嵌套，简化判断逻辑 [建议] 对于单一变量的多条件判断，在保证阅读体验的基础上，应减少代码量，避免臃肿 异常处理 [强制] catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理 Why? 对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 [建议] 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容 语言特性 引用 [强制] 所有的赋值都用const，避免使用var. eslint: prefer-const, no-const-assign Why? 因为这个确保你不会改变你的初始值，重复引用会导致 bug 和代码难以理解 // bad var a = 1; var b = 2; // good const a = 1; const b = 2; [强制] 如果你一定要对参数重新赋值，那就用let，而不是var. eslint: no-var Why? 因为let是块级作用域，而var是函数级作用域 // bad var count = 1; if (true) { count += 1; } // good, use the let. let count = 1; if (true) { count += 1; } [强制] 注意： let、const都是块级作用域 // const 和 let 都只存在于它定义的那个块级作用域 { let a = 1; const b = 1; } console.log(a); // ReferenceError console.log(b); // ReferenceError 对象 [建议] 使用字面值创建对象. eslint: no-new-object // bad const item = new Object(); // good const item = {}; [建议] 当创建一个带有动态属性名的对象时，用计算后属性名. Why? 这可以使你将定义的所有属性放在对象的一个地方 function getKey(k) { return `a key named ${k}`; } // bad const obj = { id: 5, name: 'San Francisco', }; obj[getKey('enabled')] = true; // good getKey('enabled')是动态属性名 const obj = { id: 5, name: 'San Francisco', [getKey('enabled')]\\: true, }; [强制] 用对象方法简写. eslint: object-shorthand // bad const atom = { value: 1, addValue: function (value) { return atom.value + value; }, }; // good const atom = { value: 1, // 对象的方法 addValue(value) { return atom.value + value; }, }; [强制] 用属性值缩写. eslint: object-shorthand Why? 这样写的更少且更可读 const lukeSkywalker = 'Luke Skywalker'; // bad const obj = { lukeSkywalker: lukeSkywalker, }; // good const obj = { lukeSkywalker, }; [建议] 将你的所有缩写放在对象声明的开始. Why? 这样也是为了更方便的知道有哪些属性用了缩写 const anakinSkywalker = 'Anakin Skywalker'; const lukeSkywalker = 'Luke Skywalker'; // bad const obj = { episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker, }; // good const obj = { lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4, }; [强制] 只对那些无效的标示使用引号 ''. eslint: quote-props Why? 通常我们认为这种方式主观上易读。他优化了代码高亮，并且也更容易被许多 JS 引擎压缩。 // bad const bad = { foo: 3, bar: 4, 'data-blah': 5, }; // good const good = { foo: 3, bar: 4, 'data-blah': 5, }; [建议] 不要直接调用Object.prototype上的方法，如hasOwnProperty, propertyIsEnumerable, isPrototypeOf。 Why? 在一些有问题的对象上， 这些方法可能会被屏蔽掉 - 如：{ hasOwnProperty: false } - 或这是一个空对象Object.create(null) // bad console.log(object.hasOwnProperty(key)); // good console.log(Object.prototype.hasOwnProperty.call(object, key)); // best const has = Object.prototype.hasOwnProperty; // 在模块作用内做一次缓存 /* or */ import has from 'has'; // https://www.npmjs.com/package/has // ... console.log(has.call(object, key)); [建议] 对象浅拷贝时，更推荐使用扩展运算符[就是...运算符]，而不是Object.assign。获取对象指定的几个属性时，用对象的 rest 解构运算符[也是...运算符]更好。 这一段不太好翻译出来， 大家看下面的例子就懂了。^.^ // very bad const original = { a: 1, b: 2 }; const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠ delete copy.a; // so does this // bad const original = { a: 1, b: 2 }; const copy = Object.assign({}, original, { c: 3 }); // copy => { a: 1, b: 2, c: 3 } // good es6扩展运算符 ... const original = { a: 1, b: 2 }; // 浅拷贝 const copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 } // rest 赋值运算符 const { a, ...noA } = copy; // noA => { b: 2, c: 3 } 数组 [建议] 用字面量赋值。 eslint: no-array-constructor // bad const items = new Array(); // good const items = []; [强制] 用Array#push 代替直接向数组中添加一个值。 const someStack = []; // bad someStack[someStack.length] = 'abracadabra'; // good someStack.push('abracadabra'); [建议] 用扩展运算符做数组浅拷贝，类似上面的对象浅拷贝 // bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i [建议] 用 ... 运算符而不是Array.from来将一个可迭代的对象转换成数组。 const foo = document.querySelectorAll('.foo'); // good const nodes = Array.from(foo); // best const nodes = [...foo]; [强制] 用 Array.from 去将一个类数组对象转成一个数组。 const arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 }; // bad const arr = Array.prototype.slice.call(arrLike); // good const arr = Array.from(arrLike); [建议] 用 Array.from 而不是 ... 运算符去做 map 遍历。 因为这样可以避免创建一个临时数组。 // bad const baz = [...foo].map(bar); // good const baz = Array.from(foo, bar); [强制] 在数组方法的回调函数中使用 return 语句。 如果函数体由一条返回一个表达式的语句组成， 并且这个表达式没有副作用， 这个时候可以忽略return。 eslint: array-callback-return // good .map(x => { const y = x + 1; return x * y; }); // good 函数只有一个语句 .map(x => x + 1); // bad - 没有返回值， 因为在第一次迭代后acc 就变成undefined了 [ , , , ].reduce((acc, item, index) => { const flatten = acc.concat(item); acc[index] = flatten; }); // good [ , , , ].reduce((acc, item, index) => { const flatten = acc.concat(item); acc[index] = flatten; return flatten; }); // bad inbox.filter(msg => { const { subject, author } = msg; if (subject === 'Mockingbird') { return author === 'Harper Lee'; } else { return false; } }); // good inbox.filter(msg => { const { subject, author } = msg; if (subject === 'Mockingbird') { return author === 'Harper Lee'; } return false; }); [强制] 如果一个数组有很多行，在数组的 [ 后和 ] 前断行。 请看下面示例 // bad const arr = [ [0, 1], [2, 3], [4, 5], ]; const objectInArray = [{ id: 1, }, { id: 2, }]; const numberInArray = [ 1, 2, ]; // good const arr = [[0, 1], [2, 3], [4, 5]]; const objectInArray = [ { id: 1, }, { id: 2, }, ]; const numberInArray = [ 1, 2, ]; [建议] 在编写底层组件时，数组循环尽量使用for Why? for循环效率最高 解构 [强制] 用对象的解构赋值来获取和使用对象某个或多个属性值。 eslint: prefer-destructuring Why? 解构使您不必为这些属性创建临时引用 // bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName} ${lastName}`; } // good function getFullName(user) { const { firstName, lastName } = user; return `${firstName} ${lastName}`; } // best function getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`; } [强制] 用数组解构. const arr =; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr; [建议] 多个返回值用对象的解构，而不是数组解构。 Why? 你可以在后期添加新的属性或者变换变量的顺序而不会打破原有的调用 // bad function processInput(input) { // 然后就是见证奇迹的时刻 return [left, right, top, bottom]; } // 调用者需要想一想返回值的顺序 const [left, __, top] = processInput(input); // good function processInput(input) { // oops， 奇迹又发生了 return { left, right, top, bottom }; } // 调用者只需要选择他想用的值就好了 const { left, top } = processInput(input); 字符串 [建议] 对 string 用反引号 。 eslint: quotes // bad const name = 'Capt. Janeway'; // bad - 样例应该包含插入文字或换行 const name = `Capt. Janeway`; // good const name = 'Capt. Janeway'; [建议] 超过 100 个字符的字符串不应该用 string 串联成多行。 Why? 被折断的字符串工作起来是糟糕的而且使得代码更不易被搜索。 // bad const errorMessage = 'This is a super long error that was thrown because \\ of Batman. When you stop to think about how Batman had anything to do \\ with this, you would get nowhere \\ fast.'; // bad const errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.'; // good const errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; [强制] 用字符串模板而不是字符串拼接来组织可编程字符串。 eslint: prefer-template template-curly-spacing Why? 模板字符串更具可读性、语法简洁、字符串插入参数。 // bad function sayHi(name) { return 'How are you, ' + name + '?'; } // bad function sayHi(name) { return ['How are you, ', name, '?'].join(); } // bad function sayHi(name) { return `How are you, ${name}?`; } // good function sayHi(name) { return `How are you, ${name}?`; } [强制] 永远不要在字符串中用eval()，他就是潘多拉盒子。 eslint: no-eval [强制] 不要使用不必要的转义字符。eslint: no-useless-escape Why? 反斜线可读性差，所以他们只在必须使用时才出现哦 // bad const foo = '\\'this\\' is \"quoted\"'; // good const foo = '\\'this\\' is \"quoted\"'; //best const foo = `my name is '${name}'`; 函数 [建议] 用命名函数表达式而不是函数声明。eslint: func-style 函数表达式： const func = function () {} 函数声明： function func() {} Why? 函数声明时作用域被提前了，这意味着在一个文件里函数很容易（太容易了）在其定义之前被引用。这样伤害了代码可读性和可维护性。如果你发现一个函数又大又复杂，这个函数妨碍这个文件其他部分的理解性，这可能就是时候把这个函数单独抽成一个模块了。别忘了给表达式显示的命名，不用管这个名字是不是由一个确定的变量推断出来的，这消除了由匿名函数在错误调用栈产生的所有假设，这在现代浏览器和类似 babel 编译器中很常见 (Discussion) Why? 这一段还不理解这种错误发生的场景，所以只能直译过来了， 另附原文 Why? Function declarations are hoisted, which means that it’s easy - too easy - to reference the function before it is defined in the file. This harms readability and maintainability. If you find that a function’s definition is large or complex enough that it is interfering with understanding the rest of the file, then perhaps it’s time to extract it to its own module! Don’t forget to explicitly name the expression, regardless of whether or not the name is inferred from the containing variable (which is often the case in modern browsers or when using compilers such as Babel). This eliminates any assumptions made about the Error’s call stack. (Discussion) // bad function foo() { // ... } // bad const foo = function () { // ... }; // good // lexical name distinguished from the variable-referenced invocation(s) // 函数表达式名和声明的函数名是不一样的 const short = function longUniqueMoreDescriptiveLexicalFoo() { // ... }; [强制] 把立即执行函数包裹在圆括号里。 eslint: wrap-iife Why? immediately invoked function expression = IIFE Why? 一个立即调用的函数表达式是一个单元 - 把它和他的调用者（圆括号）包裹起来，在括号中可以清晰的地表达这些。 Why? 注意：在模块化世界里，你几乎用不着 IIFE // immediately-invoked function expression (IIFE) (function () { console.log('Welcome to the Internet. Please follow me.'); })(); [强制] 不要在非函数块（if、while 等等）内声明函数。把这个函数分配给一个变量。浏览器会允许你这样做，但浏览器解析方式不同，这是一个坏消息。【详见no-loop-func】 eslint: no-loop-func Note: 在 ECMA-262 中 [块 block] 的定义是： 一系列的语句； 但是函数声明不是一个语句。 函数表达式是一个语句。 // bad if (currentUser) { function test() { console.log('Nope.'); } } // good let test; if (currentUser) { test = () => { console.log('Yup.'); }; } [强制] 不要用arguments命名参数。他的优先级高于每个函数作用域自带的 arguments 对象， 这会导致函数自带的 arguments 值被覆盖 // bad function foo(name, options, arguments) { // ... } // good function foo(name, options, args) { // ... } [强制] 不要使用arguments，用 rest 语法...代替。 eslint: prefer-rest-params Why? ...明确你想用那个参数。而且 rest 参数是真数组，而不是类似数组的arguments // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(''); } // good function concatenateAll(...args) { return args.join(''); } [强制] 用默认参数语法而不是在函数里对参数重新赋值。 // really bad function handleThings(opts) { // 不， 我们不该改arguments // 第二： 如果 opts 的值为 false, 它会被赋值为 {} // 虽然你想这么写， 但是这个会带来一些细微的bug opts = opts || {}; // ... } // still bad function handleThings(opts) { if (opts === void 0) { opts = {}; } // ... } // good function handleThings(opts = {}) { // ... } [强制] 默认参数避免副作用 Why? 他会令人迷惑不解， 比如下面这个， a 到底等于几， 这个需要想一下。 var b = 1; // bad function count(a = b++) { console.log(a); } count(); // 1 count(); // 2 count(3); // 3 count(); // 3 [建议] 把默认参数赋值放在最后 // bad function handleThings(opts = {}, name) { // ... } // good function handleThings(name, opts = {}) { // ... } [强制] 不要用函数构造器创建函数。 eslint: no-new-func Why? 以这种方式创建函数将类似于字符串 eval()，这会打开漏洞。 // bad var add = new Function('a', 'b', 'return a + b'); // still bad var subtract = Function('a', 'b', 'return a - b'); [强制] 函数签名部分要有空格。eslint: space-before-function-paren space-before-blocks Why? 统一性好，而且在你添加/删除一个名字的时候不需要添加/删除空格 // bad const f = function(){}; const g = function (){}; const h = function() {}; // good const x = function () {}; const y = function a() {}; [强制] 不要改参数. eslint: no-param-reassign Why? 操作参数对象对原始调用者会导致意想不到的副作用。 就是不要改参数的数据结构，保留参数原始值和数据结构。 // bad function f1(obj) { obj.key = 1; } // good function f2(obj) { const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1; } [强制] 不要对参数重新赋值。 eslint: no-param-reassign Why? 参数重新赋值会导致意外行为，尤其是对 arguments。这也会导致优化问题，特别是在 V8 里 // bad function f1(a) { a = 1; // ... } function f2(a) { if (!a) { a = 1; } // ... } // good function f3(a) { const b = a || 1; // ... } function f4(a = 1) { // ... } [强制] 用spread操作符...去调用多变的函数更好。 eslint: prefer-spread Why? 这样更清晰，你不必提供上下文，而且你不能轻易地用apply来组成new // bad const x =; console.log.apply(console, x); // good const x =; console.log(...x); // bad new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]))(); // good new Date(...[2016, 8, 5]); [强制] 调用或者书写一个包含多个参数的函数应该像这个指南里的其他多行代码写法一样： 每行只包含一个参数，每行逗号结尾。 // bad function foo(bar, baz, quux) { // ... } // good 缩进不要太过分 function foo( bar, baz, quux, ) { // ... } // bad console.log(foo, bar, baz); // good console.log( foo, bar, baz, ); 箭头函数 [建议] 当你一定要用函数表达式（在回调函数里）的时候就用箭头表达式吧。 eslint: prefer-arrow-callback, arrow-spacing Why? 他创建了一个this的当前执行上下文的函数的版本，这通常就是你想要的；而且箭头函数是更简洁的语法 Why? 什么时候不用箭头函数： 如果你有一个相当复杂的函数，你可能会把这个逻辑移出到他自己的函数声明里。 // bad .map(function (x) { const y = x + 1; return x * y; }); // good .map(x => { const y = x + 1; return x * y; }); [强制] 如果函数体由一个没有副作用的表达式语句组成，删除大括号和 return。否则，继续用大括号和 return 语句。 eslint: arrow-parens, arrow-body-style Why? 语法糖，当多个函数链在一起的时候好读 // bad .map(number => { const nextNumber = number + 1; `A string containing the ${nextNumber}.`; }); // good .map(number => `A string containing the ${number}.`); // good .map(number => { const nextNumber = number + 1; return `A string containing the ${nextNumber}.`; }); // good .map((number, index) => ({ [index]\\: number, })); // 表达式有副作用就不要用隐式return function foo(callback) { const val = callback(); if (val === true) { // Do something if callback returns true } } let bool = false; // bad // 这种情况会return bool = true, 不好 foo(() => (bool = true)); // good foo(() => { bool = true; }); [建议] 万一表达式涉及多行，把他包裹在圆括号里更可读。 Why? 这样清晰的显示函数的开始和结束 // bad ['get', 'post', 'put'].map(httpMethod => Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod ) ); // good ['get', 'post', 'put'].map(httpMethod => ( Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod ) )); [建议] 如果你的函数只有一个参数并且函数体没有大括号，就删除圆括号。否则，参数总是放在圆括号里。 注意： 一直用圆括号也是没问题，只需要配置 “always” option for eslint. eslint: arrow-parens Why? 这样少一些混乱， 其实没啥语法上的讲究，就保持一个风格。 // bad [1, 2, 3].map((x) => x * x); // good [1, 2, 3].map(x => x * x); // good [1, 2, 3].map(number => ( `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!` )); // bad [1, 2, 3].map(x => { const y = x + 1; return x * y; }); // good [1, 2, 3].map((x) => { const y = x + 1; return x * y; }); [强制] 避免箭头函数(=>)和比较操作符（=）混淆. eslint: no-confusing-arrow // bad const itemHeight = (item) => item.height item.height >= 256 ? item.largeSize : item.smallSize; // good const itemHeight = (item) => (item.height { const { height, largeSize, smallSize } = item; return height [强制] 在隐式 return 中强制约束函数体的位置， 就写在箭头后面。 eslint: implicit-arrow-linebreak // bad (foo) => bar; (foo) => (bar); // good (foo) => bar; (foo) => (bar); (foo) => ( bar ) 类 & 构造函数 [建议] 常用class，避免直接操作prototype Why? class语法更简洁更易理解 // bad function Queue(contents = []) { this.queue = [...contents]; } Queue.prototype.pop = function () { const value = this.queue[0]; this.queue.splice(0, 1); return value; }; // good class Queue { constructor(contents = []) { this.queue = [...contents]; } pop() { const value = this.queue[0]; this.queue.splice(0, 1); return value; } } [建议] 用extends实现继承 Why? 它是一种内置的方法来继承原型功能而不打破instanceof // bad const inherits = require('inherits'); function PeekableQueue(contents) { Queue.apply(this, contents); } inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function () { return this.queue[0]; }; // good class PeekableQueue extends Queue { peek() { return this.queue[0]; } } [建议] 方法可以返回this来实现方法链 // bad Jedi.prototype.jump = function () { this.jumping = true; return true; }; Jedi.prototype.setHeight = function (height) { this.height = height; }; const luke = new Jedi(); luke.jump(); // => true luke.setHeight(20); // => undefined // good class Jedi { jump() { this.jumping = true; return this; } setHeight(height) { this.height = height; return this; } } const luke = new Jedi(); luke.jump().setHeight(20); [建议] 写一个定制的 toString()方法是可以的，只要保证它是可以正常工作且没有副作用的 class Jedi { constructor(options = {}) { this.name = options.name || 'no name'; } getName() { return this.name; } toString() { return `Jedi - ${this.getName()}`; } } [强制] 如果没有具体说明，类有默认的构造方法。一个空的构造函数或只是代表父类的构造函数是不需要写的。 eslint: no-useless-constructor // bad class Jedi { constructor() {} getName() { return this.name; } } // bad class Rey extends Jedi { // 这种构造函数是不需要写的 constructor(...args) { super(...args); } } // good class Rey extends Jedi { constructor(...args) { super(...args); this.name = 'Rey'; } } [强制] 避免重复类成员。 eslint: no-dupe-class-members Why? 重复类成员会默默的执行最后一个 —— 重复本身也是一个 bug // bad class Foo { bar() { return 1; } bar() { return 2; } } // good class Foo { bar() { return 1; } } // good class Foo { bar() { return 2; } } [建议] 除非外部库或框架需要使用特定的非静态方法，否则类方法应该使用this或被做成静态方法。 作为一个实例方法应该表明它根据接收者的属性有不同的行为。eslint: class-methods-use-this // bad class Foo { bar() { console.log('bar'); } } // good - this 被使用了 class Foo { bar() { console.log(this.bar); } } // good - constructor 不一定要使用this class Foo { constructor() { // ... } } // good - 静态方法不需要使用 this class Foo { static bar() { console.log('bar'); } } 模块 [强制] 一个路径只 import 一次。 eslint: no-duplicate-imports Why? 从同一个路径下 import 多行会使代码难以维护 // bad import foo from 'foo'; // … some other imports … // import { named1, named2 } from 'foo'; // good import foo, { named1, named2 } from 'foo'; // good import foo, { named1, named2 } from 'foo'; [强制] 不要导出可变的东西 eslint: import/no-mutable-exports Why? 变化通常都是需要避免，特别是当你要输出可变的绑定。虽然在某些场景下可能需要这种技术，但总的来说应该导出常量。 // bad let foo = 3; export { foo }; // good const foo = 3; export { foo }; [强制] 在一个单一导出模块里，用 export default 更好。 eslint: import/prefer-default-export Why? 鼓励使用更多文件，每个文件只做一件事情并导出，这样可读性和可维护性更好。 // bad export function foo() {} // good export default function foo() {} [建议] import 放在其他所有语句之前。 eslint: import/first Why? 让import放在最前面防止意外行为。 // bad import foo from 'foo'; foo.init(); import bar from 'bar'; // good import foo from 'foo'; import bar from 'bar'; foo.init(); [建议] 多行 import 应该缩进，就像多行数组和对象字面量 Why? 花括号与样式指南中每个其他花括号块遵循相同的缩进规则，逗号也是。 // bad import { longNameA, longNameB, longNameC, longNameD, longNameE } from 'path'; // good import { longNameA, longNameB, longNameC, longNameD, longNameE, } from 'path'; [强制] 在 import 语句里不允许 Webpack loader 语法 eslint: import/no-webpack-loader-syntax Why? 一旦用 Webpack 语法在 import 里会把代码耦合到模块绑定器。最好是在webpack.config.js里写 webpack loader 语法 // bad import fooSass from 'css!sass!foo.scss'; import barCss from 'style!css!bar.css'; // good import fooSass from 'foo.scss'; import barCss from 'bar.css'; 属性 [强制] 访问属性时使用点符号. eslint: dot-notation const luke = { jedi: true, age: 28, }; // bad const isJedi = luke['jedi']; // good const isJedi = luke.jedi; [强制] 当获取的属性是变量时用方括号[]取 const luke = { jedi: true, age: 28, }; function getProp(prop) { return luke[prop]; } const isJedi = getProp('jedi'); [强制] 做幂运算时用幂操作符 ** 。 eslint: no-restricted-properties. // bad const binary = Math.pow(2, 10); // good const binary = 2 ** 10; 变量 [强制] 用const或let声明变量。不这样做会导致全局变量。 我们想要避免污染全局命名空间。 eslint: no-undef prefer-const // bad superPower = new SuperPower(); // good const superPower = new SuperPower(); [强制] 每个变量都用一个 const 或 let。 eslint: one-var Why? 这种方式很容易去声明新的变量，你不用去考虑把;调换成,，或者引入一个只有标点的不同的变化。这种做法也可以是你在调试的时候单步每个声明语句，而不是一下跳过所有声明。 // bad const items = getItems(), goSportsTeam = true, dragonball = 'z'; // bad // (compare to above, and try to spot the mistake) const items = getItems(), goSportsTeam = true; dragonball = 'z'; // good const items = getItems(); const goSportsTeam = true; const dragonball = 'z'; [建议] const放一起，let放一起 Why? 在你需要分配一个新的变量， 而这个变量依赖之前分配过的变量的时候，这种做法是有帮助的 // bad let i, len, dragonball, items = getItems(), goSportsTeam = true; // bad let i; const items = getItems(); let dragonball; const goSportsTeam = true; let len; // good const goSportsTeam = true; const items = getItems(); let dragonball; let i; let length; [建议] 在你需要的地方声明变量，但是要放在合理的位置 Why? let 和 const 都是块级作用域而不是函数级作用域 // bad - unnecessary function call function checkName(hasName) { const name = getName(); if (hasName === 'test') { return false; } if (name === 'test') { this.setName(''); return false; } return name; } // good function checkName(hasName) { if (hasName === 'test') { return false; } // 在需要的时候分配 const name = getName(); if (name === 'test') { this.setName(''); return false; } return name; } [强制] 不要使用链接变量分配。 eslint: no-multi-assign Why? 链接变量分配创建隐式全局变量。 // bad (function example() { // JavaScript 将这一段解释为 // let a = ( b = ( c = 1 ) ); // let 只对变量 a 起作用; 变量 b 和 c 都变成了全局变量 let a = (b = c = 1); })(); console.log(a); // undefined console.log(b); // 1 console.log(c); // 1 // good (function example() { let a = 1; let b = a; let c = a; })(); console.log(a); // undefined console.log(b); // undefined console.log(c); // undefined // `const` 也是如此 [建议] 不要使用一元自增自减运算符（++， --）. eslint no-plusplus Why? 根据 eslint 文档，一元增量和减量语句受到自动分号插入的影响，并且可能会导致应用程序中的值递增或递减的无声错误。 使用num + = 1而不是num ++或num ++语句来表达你的值也是更有表现力的。 禁止一元增量和减量语句还会阻止您无意地预增/预减值，这也会导致程序出现意外行为。 // bad const array =; let num = 1; num++; --num; let sum = 0; let truthyCount = 0; for (let i = 0; i a + b, 0); const truthyCount = array.filter(Boolean).length; [强制] 在赋值的时候避免在 = 前/后换行。 如果你的赋值语句超出 max-len， 那就用小括号把这个值包起来再换行。 eslint operator-linebreak. Why? 在 = 附近换行容易混淆这个赋值语句。 // bad const foo = superLongLongLongLongLongLongLongLongFunctionName(); // bad const foo = 'superLongLongLongLongLongLongLongLongString'; // good const foo = ( superLongLongLongLongLongLongLongLongFunctionName() ); // good const foo = 'superLongLongLongLongLongLongLongLongString'; [建议] 不允许有未使用的变量。 eslint: no-unused-vars Why? 一个声明了但未使用的变量更像是由于重构未完成产生的错误。这种在代码中出现的变量会使阅读者迷惑。 // bad var some_unused_var = 42; // 写了没用 var y = 10; y = 5; // 变量改了自己的值，也没有用这个变量 var z = 0; z = z + 1; // 参数定义了但未使用 function getX(x, y) { return x; } // good function getXPlusY(x, y) { return x + y; } var x = 1; var y = a + 2; alert(getXPlusY(x, y)); // 'type' 即使没有使用也可以可以被忽略， 因为这个有一个 rest 取值的属性。 // 这是从对象中抽取一个忽略特殊字段的对象的一种形式 var { type, ...coords } = data; // 'coords' 现在就是一个没有 'type' 属性的 'data' 对象 声明提升 [强制] var声明会被提前到他的作用域的最前面，它分配的值还没有提前。const 和 let被赋予了新的调用概念时效区 —— Temporal Dead Zones (TDZ)。 重要的是要知道为什么 typeof 不再安全. // 我们知道这个不会工作，假设没有定义全局的notDefined function example() { console.log(notDefined); // => throws a ReferenceError } // 在你引用的地方之后声明一个变量，他会正常输出是因为变量作用域上升。 // 注意： declaredButNotAssigned的值没有上升 function example() { console.log(declaredButNotAssigned); // => undefined var declaredButNotAssigned = true; } // 解释器把变量声明提升到作用域最前面， // 可以重写成如下例子， 二者意义相同 function example() { let declaredButNotAssigned; console.log(declaredButNotAssigned); // => undefined declaredButNotAssigned = true; } // 用 const， let就不一样了 function example() { console.log(declaredButNotAssigned); // => throws a ReferenceError console.log(typeof declaredButNotAssigned); // => throws a ReferenceError const declaredButNotAssigned = true; } [强制] 匿名函数表达式和 var 情况相同 function example() { console.log(anonymous); // => undefined anonymous(); // => TypeError anonymous is not a function var anonymous = function () { console.log('anonymous function expression'); }; } [强制] 已命名函数表达式提升他的变量名，不是函数名或函数体 function example() { console.log(named); // => undefined named(); // => TypeError named is not a function superPower(); // => ReferenceError superPower is not defined var named = function superPower() { console.log('Flying'); }; } // 函数名和变量名一样是也如此 function example() { console.log(named); // => undefined named(); // => TypeError named is not a function var named = function named() { console.log('named'); }; } [强制] 函数声明则提升了函数名和函数体 function example() { superPower(); // => Flying function superPower() { console.log('Flying'); } } 详情请见JavaScript Scoping & Hoisting by Ben Cherry. 比较运算 & 全等 [建议] 用 === 和 !== 而不是 == 和 !=. eslint: eqeqeq 条件语句如if语句使用强制ToBoolean抽象方法来评估它们的表达式，并且始终遵循以下简单规则： Objects 计算成 true Undefined 计算成 false Null 计算成 false Booleans 计算成 the value of the boolean Numbers +0, -0, or NaN 计算成 false 其他 true Strings '' 计算成 false 其他 true if ([0] && []) { // true // 数组（即使是空数组）是对象，对象会计算成true } [建议] 布尔值用缩写，而字符串和数字要明确比较对象 // bad if (isValid === true) { // ... } // good if (isValid) { // ... } // bad if (name) { // ... } // good if (name !== '') { // ... } // bad if (collection.length) { // ... } // good if (collection.length > 0) { // ... } 更多信息请见 Angus Croll 的真理、平等和 JavaScript —— Truth Equality and JavaScript [强制] 在case和default分句里用大括号创建一块包含语法声明的区域(e.g. let, const, function, and class). eslint rules: no-case-declarations. Why? 语法声明在整个switch的代码块里都可见，但是只有当其被分配后才会初始化，他的初始化时当这个case被执行时才产生。 当多个case分句试图定义同一个事情时就出问题了 // bad switch (foo) { case 1: let x = 1; break; case 2: const y = 2; break; case 3: function f() { // ... } break; default: class C {} } // good switch (foo) { case 1: { let x = 1; break; } case 2: { const y = 2; break; } case 3: { function f() { // ... } break; } case 4: bar(); break; default: { class C {} } } [建议] 三元表达式不应该嵌套，通常是单行表达式。 eslint rules: no-nested-ternary. // bad const foo = maybe1 > maybe2 ? 'bar' : value1 > value2 ? 'baz' : null; // better const maybeNull = value1 > value2 ? 'baz' : null; const foo = maybe1 > maybe2 ? 'bar' : maybeNull; // best const maybeNull = value1 > value2 ? 'baz' : null; const foo = maybe1 > maybe2 ? 'bar' : maybeNull; [强制] 避免不需要的三元表达式 eslint rules: no-unneeded-ternary. // bad const foo = a ? a : b; const bar = c ? true : false; const baz = c ? false : true; // good const foo = a || b; const bar = !!c; const baz = !c; [强制] 用圆括号来混合这些操作符。 只有当标准的算术运算符(+, -, *, & /)， 并且它们的优先级显而易见时，可以不用圆括号括起来。 eslint: no-mixed-operators Why? 这提高了可读性，并且明确了开发者的意图 // bad const foo = a && b 0 || d + 1 === 0; // bad const bar = a ** b - 5 % d; // bad // 别人会陷入(a || b) && c 的迷惑中 if (a || b && c) { return d; } // good const foo = (a && b 0 || (d + 1 === 0); // good const bar = (a ** b) - (5 % d); // good if (a || (b && c)) { return d; } // good const bar = a + b / c * d; 代码块 [强制] 用大括号包裹多行代码块。 eslint: nonblock-statement-body-position // bad if (test) return false; // good if (test) return false; // good if (test) { return false; } // bad function foo() { return false; } // good function bar() { return false; } [强制] if表达式的else和if的关闭大括号在一行。 eslint: brace-style // bad if (test) { thing1(); thing2(); } else { thing3(); } // good if (test) { thing1(); thing2(); } else { thing3(); } [建议] 如果 if 语句中总是需要用 return 返回， 那后续的 else 就不需要写了。 if 块中包含 return， 它后面的 else if 块中也包含了 return， 这个时候就可以把 return 分到多个 if 语句块中。 eslint: no-else-return // bad function foo() { if (x) { return x; } else { return y; } } // bad function cats() { if (x) { return x; } else if (y) { return y; } } // bad function dogs() { if (x) { return x; } else { if (y) { return y; } } } // good function foo() { if (x) { return x; } return y; } // good function cats() { if (x) { return x; } if (y) { return y; } } // good function dogs(x) { if (x) { if (z) { return y; } } else { return z; } } 控制语句 [强制] 当你的控制语句(if, while 等)太长或者超过最大长度限制的时候， 把每一个(组)判断条件放在单独一行里。 逻辑操作符放在行首。 Why? 把逻辑操作符放在行首是让操作符的对齐方式和链式函数保持一致。这提高了可读性，也让复杂逻辑更容易看清楚。 // bad if ((foo === 123 || bar === 'abc') && doesItLookGoodWhenItBecomesThatLong() && isThisReallyHappening()) { thing1(); } // bad if (foo === 123 && bar === 'abc') { thing1(); } // bad if (foo === 123 && bar === 'abc') { thing1(); } // bad if ( foo === 123 && bar === 'abc' ) { thing1(); } // good if ( foo === 123 && bar === 'abc' ) { thing1(); } // good if ( (foo === 123 || bar === 'abc') && doesItLookGoodWhenItBecomesThatLong() && isThisReallyHappening() ) { thing1(); } // good if (foo === 123 && bar === 'abc') { thing1(); } 注释 [强制] 多行注释用 /** ... */ // bad // make() returns a new element // based on the passed in tag name // // @param {String} tag // @return {Element} element function make(tag) { // ... return element; } // good /** * make() returns a new element * based on the passed-in tag name */ function make(tag) { // ... return element; } [强制] 单行注释用//，将单行注释放在被注释区域上面。如果注释不是在第一行，那么注释前面就空一行 // bad const active = true; // is current tab // good // is current tab const active = true; // bad function getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type; } // good function getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type; } // also good function getType() { // set the default type to 'no type' const type = this._type || 'no type'; return type; } [强制] 所有注释开头空一个，方便阅读。 eslint: spaced-comment // bad //is current tab const active = true; // good // is current tab const active = true; // bad /** *make() returns a new element *based on the passed-in tag name */ function make(tag) { // ... return element; } // good /** * make() returns a new element * based on the passed-in tag name */ function make(tag) { // ... return element; } [强制] 文件顶部必须包含文件注释，文件注释需要包含以下几个内容： @file 标明文件的用途 @author 按照责任进行排序。通常来说，就是找第一个人应该比找第二个人有效。@author中的名字原则上不允许删除。任何劳动成果都值得被尊重 /** * @file 文件描述 * @author author-name(mail-name@domain.com) */ [建议] 函数/方法添加注释需要包含入参与出参说明 /** * 函数描述 * * @param {Object} option 参数描述 * @param {string} option.url option项描述 * @param {string=} option.method option项描述，可选参数 * @param {string} a 参数1的说明 * @param {string} b 参数2的说明，比较长 * 那就换行了. * @return {Object} 返回值描述 */ function foo(option, a, b){ // TODO return {}; } [建议] 常量注释包含说明和类型信息 /** * 常量说明 * * @const * @type {string} */ var REQUEST_URL ='myurl.do'; [强制] 对于内部实现、不容易理解的逻辑说明、摘要信息等，需要写细节注释，细节注释遵循单行注释的格式 function foo(p1, p2, opt_p3){ // 这里对具体内部逻辑进行说明 // 说明太长需要换行 for(...){ .... } } [强制] 在代码不完善的地方使用特殊标记注释，特殊标记包含以下几个： TODO 有功能待实现。此时需要对将要实现的功能进行简单说明。 FIXME 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。 HACK 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。 class Calculator extends Abacus { constructor() { super(); // TODO: total should be configurable by an options param this.total = 0; } } [强制] 对于暂时不使用注释的代码块，必须写明注释，不允许简单的注释掉 Why? 代码被注释有2种原因。1、后续会恢复这段代码逻辑；2、永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。 [强制] 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 Why? 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。 [强制] 与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可 [强制] 好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担 类型转换 [强制] 请在注释中解释为什么要用移位运算和你在做什么。无论你做什么狂野的事，比如由于 parseInt 是你的性能瓶颈导致你一定要用移位运算。 请说明这个是因为性能原因, // good /** * parseInt是代码运行慢的原因 * 用Bitshifting将字符串转成数字使代码运行效率大幅增长 */ const val = inputValue >> 0; 注意: 用移位运算要小心. 数字使用64-位表示的，但移位运算常常返回的是 32 为整形source)。移位运算对大于 32 位的整数会导致意外行为。Discussion. 最大的 32 位整数是 2,147,483,647: 2147483647 >> 0; //=> 2147483647 2147483648 >> 0; //=> -2147483648 2147483649 >> 0; //=> -2147483647 [建议] 布尔: const age = 0; // bad const hasAge = new Boolean(age); // good const hasAge = Boolean(age); // best const hasAge = !!age; Copyright © xiek 2021 all right reserved，powered by Gitbook文档更新时间： 2021-03-11 14:42:09 "},"page/react.html":{"url":"page/react.html","title":"JS规范 - react","keywords":"","body":"node 规范 该文档主要的设计目标是统一 js 的一致性和可维护性，补充react专属部分。 使用约定 文件组织 [强制] 同一目录下不得拥有同名的.js和.jsx文件 [强制] 组件文件使用一致的.js或 .jsx。后缀禁止部分组件使用.js，部分组件使用 .jsx [强制] 每一个文件以export default的形式暴露一个组件 允许一个文件中存在多个不同的组件，但仅允许通过export default暴露一个组件，其它组件均定义为内部组件。 命名规则 [强制] 组件名称与文件名称保持相同。同时组件名称应当能体现出组件的功能，以便通过观察文件名即确定使用哪一个组件 [强制] 组件名采用大驼峰命名，遵守react对自定义组件调用的建议. eslint: react/jsx-pascal-case 对齐 [强制] 遵循以下JSX语法的对齐风格. eslint: react/jsx-closing-bracket-location // bad // good // if props fit in one line then keep it on the same line // children get indented normally // bad {showButton && } // bad { showButton && } // good {showButton && ( )} // good {showButton && } 空格 [强制] 自闭合的标签前要加一个空格. eslint: no-multi-spaces, react/jsx-tag-spacing // bad // very bad // bad // good [强制] 不要在 JSX 的花括号里边加空格. eslint: react/jsx-curly-spacing // bad // good 属性 [强制] 属性名使用小驼峰 // bad // good [强制] 对于多属性需要换行，从第一个属性开始，每个属性一行 // bad // good [建议] 当属性值为true时可以省略. eslint: react/jsx-boolean-value // bad // good // good 圆括号 [强制] 当 JSX 标签超过一行时使用圆括号包裹. eslint: react/wrap-multilines // bad render () { return } // good render () { return ( ) } // good, when single line render () { const body = hello return {body} } 标签 [强制] 没有子元素的标签需要自闭合 // bad // good [强制] 如果组件包含多行属性，在新的一行闭合标签. eslint:react/jsx-closing-bracket-location // bad // good Copyright © xiek 2021 all right reserved，powered by Gitbook文档更新时间： 2021-03-11 15:13:55 "},"page/node.html":{"url":"page/node.html","title":"JS规范 - Node","keywords":"","body":"node 规范 该文档主要的设计目标是统一 js 的一致性和可维护性，补充node端专属部分。 使用约定 Models [强制] Models以Class的维度定义。必须以面向对象的思维模式编写，禁止只是简单的接口返回 日志 [强制] 在dev环境与test环境必须对每个请求的入参和出参输出info日志，该日志在prod环境有选择的输出 Why? 没有日志在接口报错时往往无法定位问题，容易相互推诿 [强制] 避免重复打印日志，浪费磁盘空间 [建议]] 谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志 Why? 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ 可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警 注意日志输出的级别，error级别只记录系统逻辑出错、异常或者重要的错误信息。 Copyright © xiek 2021 all right reserved，powered by Gitbook文档更新时间： 2021-03-11 12:14:11 "},"page/css.html":{"url":"page/css.html","title":"CSS规范","keywords":"","body":"css 规范 该文档主要的设计目标是统一 css 的一致性和可维护性。格式样式统一使用Prettier默认风格 虽然本文档是针对 CSS 设计的，但是在使用各种 CSS 的预编译器(如 less、sass、stylus 等)时，适用的部分也应尽量遵循本文档的约定。 代码风格 文件 [强制] css文件使用utf-8编码 命名 [强制] 命名统一使用英文，禁止使用特殊字符 [强制] 样式不能包含ad、gg、guanggao、ads等含有广告含义的关键词，避免被浏览器拓展、插件屏蔽 [强制] 名称之间使用-or_(讨论)分割 [建议] 类名需要语义化，命名词穷了可以试下这个工具codelf（可能需要科学上网） 全局样式必须以 global 的首字母g_开头 命名示例： ClassName 含义 arrow 箭头图标 bg 含义 bar 栏（工具类） crumb 面包屑 btn 按钮 title 标题 chart 图表 clearfix 清除浮动 col 列 error 错误 hide 隐藏 hightlight 高亮 icon 图标 popup 弹窗 缩进、空格与空行 [强制] 统一使用 2 个空格进行代码缩进 [强制] 在规则声明的左大括号 { 前加上一个空格 [强制] 在属性的冒号 : 后面加上一个空格，前面不加空格 [强制] 规则声明的右大括号 } 独占一行 [强制] 在一个规则声明中应用了多个选择器时，每个选择器独占一行 [建议] 规则声明之间用空行分隔开 [强制] 统一采用展开格式书写样式。即一行只有一个样式属性，属性定义后必须以分号结尾 Bad .avatar { border-radius: 50%; border: 2px solid white; } .no, .nope, .not_good { // ... } #lol-no { // ... } Good .avatar { border-radius: 50%; border: 2px solid white; } .one, .selector, .per-line { // ... } 选择器 [强制] 无充分原因，禁止使用通用选择器*，使用了需注释写明原因 [强制] 无充分原因，禁止使用 id 选择器书写样式，书写了需注释写明原因 [强制] 使用新型选择器时需要注意浏览器兼容性 [强制] 应尽量避免对纯元素选择器设定样式，避免样式污染 Bad // 后期迭代有可能会在.userinfo加入新的span标签，会造成样式污染，且层级较深时，排查困难，不利于维护 .userinfo span { display: block; } Good .userinfo .name { display: block; } 值与单位 文本 [强制] css 属性值需要用到引号时，统一使用单引号 数值 [强制] 当数值为 0 - 1 之间的小数时，省略整数部分的 0 url [强制]url()函数中的路径必须加引号 颜色 [强制] 颜色值可以缩写时，必须使用缩写形式 Bad .success { color: #aaccaa; } Good .success { color: #aca; } [强制] 颜色不允许使用命名色值 Bad .success { color: red; } Good .success { color: #c00; } [强制] 颜色色值统一采用英文小写 文本编排 字体 [强制]font-family属性中字体族名称应使用英文family name，如有空格，放在引号中 字体 操作系统 family name 宋体 (中易宋体) Windows SimSun 微软雅黑 Windows Microsoft YaHei 华文黑体 Mac/iOS STHeiti 文泉驿正黑 Linux WenQuanYi Zen Hei 字号 [强制] 需要在 windows 平台显示的中文内容，其字号最小为12px 行高 [强制]line-height在定义文本段落时，应使用数值 兼容性 Hack [强制] 对于需要添加hack时尽可能采取其他方式解决。如需使用hcak，必须在所在行注释标明版本以及作用 Copyright © xiek 2021 all right reserved，powered by Gitbook文档更新时间： 2021-03-10 15:43:21 "},"page/html.html":{"url":"page/html.html","title":"HTML规范","keywords":"","body":"html 规范 该文档主要的设计目标是统一 html 的一致性和可维护性。 代码风格 文件 [强制] html文件使用utf-8编码 缩进 [强制] html 缩进统一为2个空格 命名 [强制] 除非有特定的功能、组件要求等，禁止随意使用 id 来定义元素样式 标签 [强制] 标签必须合法且闭合、嵌套正确，标签名必须小写 [强制] 标签语法无错误，需要符合语义化 [建议] 标签的自定义属性以 data-开头，如： 结构 [建议] 除非有特殊原因，禁止在内联元素内包裹块级元素 [强制] 元素嵌套建议每个块级元素独立一行，内联元素可选 [强制] 结构应尽量简洁，避免使用额外的冗余嵌套 [建议] 结构块之间应保留一个空行 [强制] html 的注释位于要注释的代码的上面，单独占一行 header title [强制] 页面必须包含title标签声明标题 favicon [强制] 保证favicon必须可访问 viewport [强制] 必须指定页面viewport以保证对移动端最基本的支持 Copyright © xiek 2021 all right reserved，powered by Gitbook文档更新时间： 2021-03-10 15:44:01 "},"page/img.html":{"url":"page/img.html","title":"图片规范","keywords":"","body":"图片 该文档主要的设计目标是统一图片导入和使用的一致性和可维护性。 原则 在保证视觉效果的基础上，为加快加载速度减少传输量，图片体积越小越好 图片命名 [强制] 图片命名建议以以下顺序命名： （mod_）图片功能类别（必选）+图片模块名称（可选）+其他区别信息（可选）+图片精度（可选） 图片功能类别 mod_：是否公共，可选 icon：图标 logo：Logo 类 btn：按钮 bg：可平铺或背景 ... 图片模块名称 userinfo：用户信息 goodslist：商品列表 goodsinfo：商品信息 ... 图片精度： 普清：@1x Retina：@2x | @3x ... 例如： // 公共的用户信息删除箭头图标 mod_icon_userinfo_del_arrow.png // 商品信息普清背景图 bg_goodsinfo@1x.jpg 内容图 内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大 优先考虑 JPEG 格式 尽量不适用 PNG，PNG8 色味太低，PNG24 压缩率低，文件体积大 背景图 背景图多为图标等颜色比较简单、文件体积不大、起装饰作用的图片 有动图效果优先考虑 GIF 格式 图像颜色比较简单的，如纯色块线条图标，优先考虑用 CSS 实现，其次考虑用 PNG8 格式，避免使用 JPEG 格式 图像颜色丰富且图片文件不太大（ 图像颜色丰富且文件比较大的（> 40KB）优先考虑 JPEG 格式 兼容条件允许时，优先考虑 WebP 代替 PNG 和 JPEG 格式 JPEG 图片条件允许，压缩至 80%品质即可，保证文字清晰。JPEG 导出时如果可以使用渐进式图片，优先使用渐进式 图片使用 [建议] 当图片尺寸可以预见时，添加width和height属性，以避免页面抖动 [建议] 无下载需求的图片原则上采用 css 背景图实现 Copyright © xiek 2021 all right reserved，powered by Gitbook文档更新时间： 2021-03-10 15:44:21 "}}